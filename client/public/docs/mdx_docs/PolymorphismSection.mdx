---
title: "Polymorphism Section"
sidebar_label: "Polymorphism"
sidebar_position: 6
description: "Polymorphism, overloading, overriding, abstract classes, and interfaces in Java."
tags: ["Key Concepts"]
---

# Polymorphism

## Overloading & Overriding

Polymorphism allows methods and objects to appear in many forms. This is achieved in Java through **overloading** and **overriding** methods.

### Overloading

Overloading allows a class to have multiple methods with the same name but different parameter types or counts.

```java
public class Vase extends Item {
    private int height;
    private String material;

    public Vase() {
        super();
        height = 0;
        material = "";
    }
    public Vase(int height, String material) {
        super();
        this.height = height;
        this.material = material;
    }
    public Vase(int value, String creator, int height, String material) {
        super(value, creator);
        this.height = height;
        this.material = material;
    }
}
```

Each constructor has a unique signature. The compiler selects the correct one based on the arguments provided.

```java
Vase v1 = new Vase(0, "Dave", 50, "bronze");
Vase v2 = new Vase(100, "plaster");
```

### Overriding

Overriding allows a subclass to provide a specific implementation of a method already defined in its superclass.

```java
public class Item {
    protected int value;
    protected String creator;
    public void input() {
        // ...
    }
    public void output() {
        // ...
    }
}

public class Vase extends Item {
    private int height;
    private String material;
    @Override
    public void input() {
        super.input();
        // ...
    }
    @Override
    public void output() {
        super.output();
        // ...
    }
}
```

Use the **@Override** annotation to indicate you are overriding a superclass method.

## Function Bindings

Java uses **static binding** (compile time) for overloaded methods and **dynamic binding** (runtime) for overridden methods.

## Abstract Classes

An **abstract class** contains abstract methods (no implementation) that must be implemented by subclasses.

```java
public abstract class Item {
    protected int value;
    protected String creator;
    public abstract void displayPrice();
}

public class Vase extends Item {
    private int height;
    private String material;
    @Override
    public void displayPrice() {
        if (height < 100)
            System.out.println("The price is 1000$");
        else
            System.out.println("The price is 2000$");
    }
}
```

Subclasses must implement all abstract methods from their superclass.

## Interfaces

An **interface** defines method signatures that implementing classes must provide. Interfaces enable multiple inheritance of type.

```java
public interface Menu {
    void getSalad();
    void getBeefsteak();
}

public class Chef implements Menu {
    public void getSalad() {
        System.out.println("This is a salad");
    }
    public void getBeefsteak() {
        System.out.println("This is a beefsteak");
    }
}
```

A class can implement multiple interfaces, providing polymorphic behavior.

## Summary

- Polymorphism allows objects and methods to take many forms.
- Overloading and overriding are key techniques for polymorphism.
- Abstract classes and interfaces enable flexible and reusable code.
- In OOP, a parent class or interface reference can refer to a child class object.

## Course Slide

- [Polymorphism.pdf](/resource/Polymorphism.pdf)
