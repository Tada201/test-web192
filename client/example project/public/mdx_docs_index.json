[
  {
    "id": "ArrayOfObjectsSection",
    "filename": "ArrayOfObjectsSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/ArrayOfObjectsSection.mdx",
    "title": "Array of Objects Section",
    "frontmatter": {
      "title": "Array of Objects Section",
      "sidebar_label": "Array of Objects",
      "sidebar_position": 7,
      "description": "Managing arrays of objects, file I/O, and serialization in Java.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Array of Objects\n\n## Array of Objects\n\nA systematic technique for accessing objects of different dynamic type within the same hierarchy is through an array of pointers of their static type. The executable code dereferences each pointer at run time based on its object's dynamic type. [read dynamic & static type](/Org_code/Inheritance.html#instanceof) again\n\nIn the previous topic, an antique shop that sells antique items, namely vases, statues, and paintings. For now, we want to manage the list of objects such as vases, statues, paintings in an array. The objects pointed to by the array elements may be of differing dynamic type, but are of the same static type (type of the superclass).\n\nFor example, we create the file named *ItemList.java*, it contains an array as follows:\n\n```java\npublic class ItemList{\n  Item [] list;   // an array to store all items\n  int numOfItem;  // to store the number of items that added to the list\n  final int MAX=100;   // is the size of the array\n  public ItemList(){\n              list=new Item[MAX];\n              numOfItem=0;\n    }    \n}\n```\n\nFollowing are the basic operations supported by an array:\n- print all the array elements(objects) one by one.\n- Adds an object at the given index.\n- Deletes an object at the given index.\n- Searches an object using the given index or by the value.\n- Updates an object at the given index.\n\nWe will implement these later. For now, the main method to test some basic functions in the antique shop.\n\n```java\npublic class antiqueShop{\n  public static void main(String[] args){\n            ItemList obj=new ItemList();\n            Scanner sc=new Scanner(System.in);\n            int choice=0;\n            do{\n                System.out.println(\"1. add a new vase\");\n                System.out.println(\"2. add a new statue\");\n                System.out.println(\"3. add a new painting\");\n                System.out.println(\"4. display all items\");\n                System.out.println(\"5. find the items by the creator \");\n                System.out.println(\"6. update the item by its index\");\n                System.out.println(\"7. remove the item by its index\");\n                System.out.println(\"8. display the list of vase items \");\n                System.out.println(\"9. sorts items in ascending order based on their values \");\n                System.out.println(\"10. exit\");\n                System.out.println(\"input your choice:\");\n                choice=sc.nextInt();\n                switch(choice){\n        case 1:\n                 Item tmp=new Vase();\n                 tmp.input();\n                 //call the addItem method at here\n                 break;\n        case 2:\n                 Item tmp2=new Statue();\n                 tmp2.input();\n                 //call the addItem method at here\n                 break;   \n        case 3:\n                 Item tmp3=new Painting();\n                 tmp3.input();\n                 //call the addItem method at here\n                 break;  \n        case 4:\n                 //call the displayAll method at here\n                 break;\n        case 5:\n                 //call the findItems method at here\n                 break;  \n        case 6:\n                 //call the updateItem method at here\n                 break;\n        case 7:\n                 //call the removeItem method at here\n                 break; \n        case 8:\n                  //call the displayItemByType method at here\n                 break;\n        case 9:\n                //call the sortItems() method at here\n                break;                              \n                }\n            }while(choice<=9);\n        }\n}\n```\n\nTo explore the instruction that is highlighted, consider the figure below:\n\n![array3](/media/array3.webp)\n\nAfter starting, the obj variable points to address 1000, this block contains the reference variable *list* that is pointing to address 2000. It is an array of pointers. All elements are initiated to *null*.\n\nTo complete the program, we add a method named *addItem* to the ItemList class.\n\n```java\npublic class ItemList{\n  ...\n  public boolean addItem(Item item){\n          if( item==null || numOfItem>=MAX)\n              return false;\n          list[numOfItem]=item;\n          numOfItem++;\n          return true;\n    }\n}\n```\n\nEdit the *case 1* in the main method:\n\n```java\npublic class antiqueShop{\n  public static void main(String[] args){\n         ....\n         switch(choice){\n            case 1:\n                Item tmp=new Vase();\n                tmp.input();\n                if(obj.addItem(tmp)){\n                    System.out.println(\"added\");\n                }\n                break;\n     }\n}\n```\n\nIf the choice is 1, steps are performed:\n1. A Vase object is created at address 300.\n2. Its state likes the sample after inputting.\n3. Address 300 is passed to the addItem method.\n4. Add this address to the array at an index that is numOfItem.\n5. Increase the numOfItem by 1\n\n![array4](/media/array4.webp)\n\nWe add more some methods to the ItemList class:\n\n```java\npublic class ItemList{\n  ...\n  //this method prints out information of all items\n  public void displayAll(){\n          if(numOfItem==0)\n              System.out.println(\"the list is empty\");\n          for(int i=0; i< numOfItem; i++){\n               System.out.println(list[i]);\n      }\n    }\n    //this method finds the item by its creator\n    //return the item that is found of the first occurrence.\n    pulic Item findItem(String creator){\n        for(int i=0; i< numOfItem; i++)\n             if( list[i].getCreator().equals(creator))\n                  return list[i];\n        return null;\n    }\n    //this method returns the zero_based index of the first occurrence.\n    pulic int findItemIndex(String creator){\n        for(int i=0; i< numOfItem; i++)\n             if( list[i].getCreator().equals(creator))\n                  return i;\n        return -1;\n    }\n    //this method updates the item at the specified position in this list\n    //input: the index you wish to update\n\n    pulic boolean updateItem(int index){\n        if( index >= 0 && index < numOfItem){\n              list[i].input();\n              return true;\n        }\n        return false;\n    }\n\n    //this method removes the item at the specified position in this list. \n    //Shifts any subsequent elements to the left   \n    //input: the index you wish to remove    \n    pulic boolean removeItem(int index){\n        if( index >= 0 && index < numOfItem){\n              for(int j=index; j< numOfItem; j++ ){\n                   list[j]=list[j+1];\n               }\n              numOfItem --; \n              return true;\n        }\n        return false;\n    }\n    //this method prints out all items that belong to the given type in the list.\n    public void displayItemsByType(String type){\n\n        if (type.equals(\"Vase\")){   \n          for(int i=0; i < numOfItem; i++)\n             if ( list[i] instanceof Vase) System.out.println( list[i]);\n        }\n        else if (type.equals(\"Statue\")){   \n          for(int i=0; i < numOfItem; i++)\n             if ( list[i] instanceof Statue) System.out.println( list[i]);\n        }\n        else {\n           for(int i=0; i < numOfItem; i++)\n             if ( list[i] instanceof Painting) System.out.println( list[i]);\n        }\n    }\n    //this method sorts items in ascending order based on their values.\n    public void sortItems(){\n        for(int i=0; i< numOfItem; i++)\n            for(int j=numOfItem-1; j>i ;j--){\n                if( list[i].getValue()< list[j-1].getValue()){\n                     Item tmp=list[j];\n                     list[j]=list[j-1];\n                     list[j-1]=tmp;\n                 }\n            }\n    }  \n}\n```\n\n```java\npublic class antiqueShop{\n  public static void main(String[] args){\n         ....\n         switch(choice){\n                case 1:\n                    Item tmp=new Vase();\n                    tmp.input();\n                    if(obj.addItem(tmp)){\n                        System.out.println(\"added\");\n                     }\n                    break;\n                case 2:\n                    Item tmp2=new Statue();\n                    tmp2.input();\n                    if(obj.addItem(tmp2)){\n                        System.out.println(\"added\");\n                    }\n                    break;\n                case 3:\n                    Item tmp3=new Painting();\n                    tmp3.input();\n                    if(obj.addItem(tmp3)){\n                        System.out.println(\"added\");\n                    }\n                    break;\n                case 4:\n                    obj.displayAll();\n                    break;\n                case 5:\n                    String creator=\"Paris\";\n                    Item result=obj.findItemIndex(creator);\n                    if( Item==null) System.out.println(\"not found\");\n                    else System.out.println(\"the item is found \" + result);\n                    break;\n                case 6:\n                    int index=2;\n                    if( obj.updateItem(index)){\n                        System.out.println(\"After updating: \");\n                        obj.displayAll();\n                    }\n                    else System.out.println(\"can not update the item\");\n                    break;\n                case 7:\n                    int index=1;\n                    if( obj.removeItem(index)){\n                        System.out.println(\"After removing: \");\n                        obj.displayAll();\n                    }\n                    else System.out.println(\"can not remove the item\");\n                    break;\n                case 8:\n                    String type=\"Painting\";\n                    obj.displayItemsByType(type);\n                    break;\n                case 9:\n                    obj.sortItems();\n                    obj.displayAll();\n            }//end switch\n            ... \n     }\n}\n```\n\n![array5](/media/array5.webp)\n\nThe *findItemIndex* method finds the item within the list and returns the position of the first occurrence in the list. For example, if you wish to get the *position* of the item which value is *100* then the method returns *0*.\n\nThe *findItem* method finds the item within the list and returns the address of the first occurrence in the list. For example, if you wish to get the *item* which creator is *Paris* then the method returns *300*.\n\nIf you wish to remove the item at index 1, the method *removeItem(index)* will shift any subsequent elements to the up. After shifting, the old item that was at position 1 becomes garbage and Java will deallocate it.\n\nIn the *sortItem* method, we implement the bubble sorting algorithm. \n\n*[ read bubble sorting algorithm in [Wiki](https://en.wikipedia.org/wiki/Bubble_sort#:~:text=Bubble%20sort,%20sometimes%20referred%20to%20as%20sinking%20sort,,list%20is%20repeated%20until%20the%20list%20is%20sorted.) ]*\n*[ read the [Arrays](https://makeinjava.com/sort-user-defined-objects-pojo-array-java-example-comparator-interface/) class to sort user-defined objects]*\n\n## I/O Stream\n\nInput and output data sources of a program can be the keyboard, monitor, file in an external disk. In this lesson, basic concepts and tools for handling all kinds of data, from primitive values to advanced objects are introduced.\n\nFile is a group of related data which are stored in external memory (disk) for the common use between some programs. The file designer will decide the format of stored data. In general, a thing containing data is called a file. So, a directory is a file, a device( keyboard, monitor, network interface card, disk,…) is a file. Data in a normal file can include text, images, sounds.  Information stored in a file must be persistent. This means that data in a file must be survived even when the process, which created it, terminated.\n\n**Text format**: a data unit is a character or digit (ASCII code). So, all numbers in a program (numeric variables) must be transferred to a string of digits before they are written to file.\n\n**Binary format**: data in a file is a figure of a variable’s memory bitmap in the program.\n\nText format is flexible than binary format but costs must be paid for type conversions. Files in text format can be viewed, updated using any normal editor such as Notepad, MS Word, …\n\nThe binary format is efficient because no data type transfer is needed but data in a file can be accessed by appropriate programs only.\n\nThe link to read more: [IO Streams](https://docs.oracle.com/javase/tutorial/essential/io/streams.html)\n\nSteps for accessing a file:\n1. Open file\n2. Read data from file to a program’s variable or write the value in the program’s variable to file\n3. Close file\n\n**Stream**\n\nAn I/O Stream represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.\n\nI/O Stream contains a reference to a data source, methods for accessing data in the source, and methods for type conversions\n\nStreams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways (type conversions may be needed).\n\nNo matter how they work internally, all streams present the same simple model to programs that use them: A stream is a sequence of data. A program uses an input stream to read data from a source, one item at a time and uses an output stream to write data to a destination, one item at a time.\n\n![IO.01](/media/IO.01.webp)\n![IO.02](/media/IO.02.webp)\n\n*[ Introduction to the [java.io package](https://docs.oracle.com/javase/7/docs/api/java/io/package-summary.html) ]*\n*[ Introduction to I/O [Stream](https://docs.oracle.com/javase/tutorial/essential/io/streams.html) ]*\n*[ Introduction to the [File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html) class ]*\n\n**In the following program, the user will give a pathname, the program will show information about this pathname in the file system.**\n\n![IO.09A](/media/IO.09A.webp)\n![IO.09B](/media/IO.09B.webp)\n![IO.09C](/media/IO.09C.webp)\n![IO.09D](/media/IO.09D.webp)\n![IO.09E](/media/IO.09E.webp)\n![IO.09E](/media/IO.09E.webp)\n\n**Accessing ASCII text files**\n\nWhen a text file is used, the file designer will decide text organization (data meanings) in a file. So, all read/write operations must perform appropriately.\n\nTwo following pictures depict ways we can use to access a text file:\n\n![IO.10](/media/IO.10.webp)\n![IO.11](/media/IO.11.webp)\n\n## Build a complete program\n\nBuild a program that is needed to help users managing a list of products.\nDetails of a product include String ID, String name, int price.\nAn initial list of products is stored in a text file, named products.txt.\nInitial data in the file as below:\nP001,  Sony TV 65, 850\nP006, Sharp TV 40, 210\nP003, TCL TV 55, 310\nP007, Bose sounddock 30 III, 500\nP002, Bose soundbar 230 I, 800\nP004, Denon soundbar S330, 1100\n\nUsers can choose an operation at a time using a simple menu. Operations are required:\n- Add a product\n- Search a product based on its ID\n- Print products based on a part of its name. For example, “TV” or “soundbar”\n- Print all products in descending order of prices.\n- Save the current list to file, named Products.txt\n\n**Constraints:**\n- The ID of a product must be in the “P000” format.\n- The product name is not blank and there is no extra blank.\n- The product’s price must be >0.\n- The product’s ID is unique.\n\n**Class design**\n- Class Inputter for inputting data to ensure that they satisfy the problem’s constraints.\n- Class Menu for program’s menu\n- Class Product for a product\n- Class ProductList for a list of products\n- Class ProductManager for the program.\n\n**Software structure and menu:**\n\n![IO.12A](/media/IO.12A.webp)\n\nNote: A class that uses classes in a package should be outside of the package. The ProductManger class is put outside of the products package.\n\n![IO.12B](/media/IO.12B.webp)\n\n**Implementations**\n\nThe Inputter class is the tool for inputting data based on the program’s constraints.\n\n![IO.12C](/media/IO.12C.webp)\n![IO.12D](/media/IO.12D.webp)\n\n**Regular Expression** A regular expression is a way or a language that helps us to describe strings that are in a pre-defined specific pattern.\nExample: “[pP][\\d]{3}”:  Pattern for “p000\", “P001”, “P909”\nMeanings of parts:\n-  [pP] : One character and it must be ‘p’ or ‘P’\n- [\\d]{3}: 3 digits\nIn the String class, we can use the boolean matches(String regEx) method to check a string whether it matches the specified regular expression or not.\n*[For more details](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/regex/Pattern.html)*\n\n![IO.12E](/media/IO.12E.webp)\n![IO.12F](/media/IO.12F.webp)\n![IO.12G](/media/IO.12G.webp)\n![IO.12H](/media/IO.12H.webp)\n![IO.12I](/media/IO.12I.webp)\n![IO.12J](/media/IO.12J.webp)\n![IO.12K](/media/IO.12K.webp)\n![IO.12L](/media/IO.12L.webp)\n![IO.12M](/media/IO.12M.webp)\n![IO.12N](/media/IO.12N.webp)\n![IO.12O](/media/IO.12O.webp)\n![IO.12P](/media/IO.12P.webp)\n![IO.12Q](/media/IO.12Q.webp)\n![IO.12R](/media/IO.12R.webp)\n![IO.12S](/media/IO.12S.webp)\n![IO.12T](/media/IO.12T.webp)\n\n**Exercise**\n\nUpgrade the Product Manager program above. Add the following extra operations to this program:\n- Print products whose prices are between min Price and max Price\n- Update name and price of a product based on its ID.\n- Remove a product based on its ID\n\n**Accessing object files**\n\n**Serialization** is a process in which binary data bytes of an object will be transferred to a stream.\n\n**De-serialization** is a process in which binary data bytes in a stream will be transferred to fields of an object.\n\nEach programming language chooses a way to serialize an object. Following are some concerns:\n- Whether class information of the object is stored in a file or not.\n- What is the order of fields that will be stored? Down order (field 1, filed 2,…) is applied or up order should be used?\n\nHow to serialize a Java object to s stream?\n\nTo serialize data of objects to a stream, a class of objects must implement the java.io.Serializabe interface. This interface has no method. The Java compiler will add systematic codes needed to serialize and de-serialize between objects and a binary stream.\n\nBecause object files are binary, users can not use text editors to see or edit data. All read and write operations must be performed by suitable programs.\n\n**What are fields will be serialized?**\n\nNot all data of an object are serialized to a stream. static and transient fields are not serialized.\nNote:\n- the static modifier is used when a field is the common field of a class.\n- the transient modifier is used when a field having value as a result of computation from other fields.  [read more](https://www.geeksforgeeks.org/transient-keyword-java/#:~:text=transient%20keyword%20in%20Java.%20transient%20is%20a%20variables,save%20default%20value%20of%20that%20variable%20data%20type.)\n\nModel for reading objects from and writing objects to an object stream.\n\n![IO.16](/media/IO.16.webp)\n\nThe following image helps us explore the structure of an object file in Java.\n\n![IO.17](/media/IO.17.webp)\n\n1. Package and class information including field names, field types (I: int) are put at the beginning of the file.\n2. Fields are written to file in reverse order.\n\nEach time objects are written to file, information about package and class will be written.  We are noticed about properties when manipulating object files as below:\n1. All objects in the file should be loaded to memory.\n2. Use the override mode to write objects to the file.\n\n**Problem**: The following demonstration will depict the way to access an object file containing some books.\n\nSoftware structure of Book Managing Program\n\n![IO.18A](/media/IO.18A.webp)\n![IO.18B](/media/IO.18B.webp)\n![IO.18C](/media/IO.18C.webp)\n![IO.18D](/media/IO.18D.webp)\n![IO.18E](/media/IO.18E.webp)\n![IO.18F](/media/IO.18F.webp)\n![IO.18G](/media/IO.18G.webp)\n![IO.18H](/media/IO.18H.webp)\n\nThe result:\n\n![IO.18I](/media/IO.18I.webp)\n\n**Exercise**\n\nDevelop the above demonstration program for managing books with the following specifications:\n- Book \\<String ID, String title, String author, int edition, int price\\>.\n- Filename: books.dat\n- Menu of the program:\n  - Add a book\n  - Search a book based on ID\n  - Update a book\n  - Remove a book\n  - Print books of an author\n  - Print books having titles containing a sub-string\n  - Print books in ascending order of authors then ascending prices  \n  - Save the list to file\n\n**Summary**\n- File is a group of related data which are stored in external memory (disk) for the common use between some programs.\n- A thing containing data is called a file. So, a directory is a file, a device (keyboard, monitor, network interface card, disk,…) is a file.  \n- An I/O Stream represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.\n- The java.io package contains interfaces and almost of classes for accessing text files and binary files including object files.\n- The java.io.File supports methods for accessing basic information of a file or folder.\n\n## Course Slide\n\n- [Array of Objects.pdf](/resource/ArrayOfObjects.pdf)\n- [File I/O.pdf](/resource/File%20IO.pdf)\n"
  },
  {
    "id": "CollectionsSection",
    "filename": "CollectionsSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/CollectionsSection.mdx",
    "title": "Collection Framework in Java",
    "frontmatter": {
      "title": "Collection Framework in Java",
      "sidebar_label": "Collections",
      "sidebar_position": 8,
      "description": "Java Collections Framework, ADTs, List, Set, Map, and supporting classes.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Collection Framework in Java\n\nIn almost all real problems, data related to a problem are groups, each group contains many objects. A group of objects is called a **collection**. In Java, a collection framework is introduced to support tools for managing collections more easily.\n\n## Overview of Abstract Data Types\n\nAn **abstract data type (ADT)** is a mathematical model for a data type, defined by its behaviors from the user's point of view. In Java, ADTs are often declared as interfaces. Collections, sets, and maps are all ADTs.\n\n- Add new element\n- Search an element\n- Remove an element\n- Traverse (access all elements one-by-one)\n- Sort elements\n\n*ADT (mathematical model, user view) contrasts with data structure, which is a concrete representation of data (implementer view, physical view).*\n\n## Java Collections Framework\n\nThe Java Collections Framework provides a unified architecture for representing and manipulating collections. It includes interfaces, implementations, and algorithms for working with groups of objects.\n\n- Reduces programming effort by providing data structures and algorithms so you don't have to write them yourself.\n- Increases performance by providing high-performance implementations of data structures and algorithms.\n- Provides interoperability between unrelated APIs by establishing a common language to pass collections back and forth.\n- Reduces the effort required to learn APIs by requiring you to learn multiple ad hoc collection APIs.\n- Reduces the effort required to design and implement APIs by not requiring you to produce ad hoc collections APIs.\n- Fosters software reuse by providing a standard interface for collections and algorithms with which to manipulate them.\n\n![Collections framework interface structure](/media/7.01.webp)\n![Collection Implementations](/media/7.0.1.1.webp)\n\nFor more details, see the [Javadoc](https://docs.oracle.com/javase/7/docs/api/java/util/package-tree.html).\n\n## List and ArrayList\n\nAll references to elements are stored in a one-dimensional array, called an array list. This organization can be used to store arbitrary elements and they can be duplicated.\n\n![ArrayList demonstration](/media/7.02.webp)\n![ArrayList characteristics](/media/7.0.2.2.webp)\n\nIf objects in a collection do not belong to the same class, references in a collection will behave as references to objects of the Object class. Based on OOP inheritance, the following assignment is valid: `Father_reference = Son_reference;`\n\nWhen using generics, you can specify the element type for type safety and to avoid casting.\n\n```java\nArrayList<Rectangle> list = new ArrayList<>();\nlist.add(new Rectangle(2, 3));\nRectangle r = list.get(0); // No cast needed\n```\n\n### Demonstrations\n\n**Demonstration 1:** Using an ArrayList of arbitrary elements.\n\n![ArrayList arbitrary elements](/media/7.03a.webp)\n![Objects of Rectangle in ArrayList](/media/7.03b.webp)\n\n**Experiment:** If you want to call a method specific to a subclass, you must cast.\n\n**Demonstration 2:** Using an ArrayList for storing the same-type elements.\n\n![ArrayList same-type elements](/media/7.04.webp)\n\n**Demonstration 3:** Managing a list of students with ArrayList.\n\n![Class Design](/media/7.05.webp)\n![Algorithm 1](/media/7.06a.webp)\n![Algorithm 2](/media/7.06b.webp)\n![Algorithm 3](/media/7.06c.webp)\n![Algorithm 4](/media/7.06d.webp)\n![Algorithm 5](/media/7.06e.webp)\n![Algorithm 6](/media/7.06f.webp)\n![Algorithm 7](/media/7.06g.webp)\n![Algorithm 8](/media/7.06h.webp)\n![Algorithm 9](/media/7.06i.webp)\n![Algorithm 10](/media/7.06j.webp)\n![Algorithm 11](/media/7.06k.webp)\n\n**Test cases:**\n```text\nStudent managing Program\n1-Add new student\n2-Search a student\n3-Update name and mark\n4-Remove a student\n5-List all\n6-Quit\nChoose 1..6:\n```\n\n## Set and TreeSet\n\nA **Set** is a group of distinct objects. The **TreeSet** class stores elements in a sorted, self-balancing tree structure. Duplicates are not allowed.\n\n![TreeSet structure](/media/7.07.webp)\n\nTreeSet is implemented as a [self-balanced ordered tree](https://www.tutorialspoint.com/data_structures_algorithms/avl_tree_algorithm.htm). It guarantees log(n) time cost for the basic operations (add, remove, and contains).\n\n- A sorted group must be maintained.\n- Search operation must have high performance.\n\nElements must implement `Comparable` or a `Comparator` must be provided. The ordering maintained by a set must be consistent with equals if it is to correctly implement the Set interface.\n\n### Demonstrations\n\n**Demonstration 1:** The Student class does not implement any comparison method, so a compile-time error occurs.\n\n![TreeSet error](/media/7.13.webp)\n\n**Demonstration 2:** TreeSet of integers (Integer implements Comparable, no duplicates allowed).\n\n![TreeSet of integers](/media/7.14.webp)\n\n**Demonstration 3:** TreeSet of user-defined objects (Student), with add, search, remove, ascending and descending traversal.\n\n![TreeSet students a](/media/7.15a.webp)\n![TreeSet students b](/media/7.15b.webp)\n![TreeSet students c](/media/7.15c.webp)\n![TreeSet students d](/media/7.15d.webp)\n![TreeSet students e](/media/7.15e.webp)\n![TreeSet students output](/media/7.15f.webp)\n\n## Map and HashMap\n\nA **Map** associates unique keys with values. The **HashMap** class provides a hash-table-based implementation of the Map interface, allowing fast access to values by key.\n\n![Map structure](/media/7.16.webp)\n\nA Map is like a dictionary. Maps check for key uniqueness based on the `equals()` method, not the `==` operator. The key can be a number or a string (such as Student ID, product ID).\n\n![Hash function and hash-table](/media/7.17.webp)\n\nA hash-table is a set of subsets but the position index is determined by a function, called a **hash function (h)**. The mathematical operation, **modulo** (or mod/ % in programming languages), is commonly used in hash functions.\n\nThis implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets.\n\nFor more details, see the [Javadoc](https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html).\n\n### Demonstration\n\n**Demonstration 1:** An empty hashmap is initiated, then some persons (nickName, person) are put and some basic operations on hashmap are performed.\n\n![HashMap demo 1](/media/7.18a.webp)\n![HashMap demo 2](/media/7.18b.webp)\n![HashMap demo 3](/media/7.18c.webp)\n![HashMap demo 4](/media/7.18d.webp)\n![HashMap demo 5](/media/7.18e.webp)\n![HashMap demo 6](/media/7.18f.webp)\n![HashMap output](/media/7.18g.webp)\n\n## Supporting Classes\n\nAlong with the Collections framework, the **java.util** package also contains supporting classes in which many operations on collections and arrays are implemented. Almost all of these methods are public static. Actions such as sorting, shuffling, copying, searching, composition, finding extreme values (min, max), etc. are implemented.\n\n| Supporting class           | Parameter of methods |\n|---------------------------|---------------------|\n| Java.util.Collections     | Collection          |\n| Java.util.Arrays          | Array               |\n\n[Read more Collections in Javadoc](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html)  \n[Read more Arrays in Javadoc](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html)\n\n**Demonstration:** An ArrayList of employees will be sorted with two mechanisms: (1) sorting by ascending ID; (2) Sorting by descending order by salary.\n\n![Sorting ArrayList of employees](/media/7.19a.webp)\n![Sorting by salary](/media/7.19b.webp)\n![Sorting output](/media/7.19c.webp)\n![Sorting output 2](/media/7.19d.webp)\n\n## Summary\n\n- Abstract data type (ADT) is a mathematical model for a data type that is determined based on generalization in which data structure is omitted. In programming languages, an ADT is commonly declared as an interface\n- Collection, Set, Map are ADTs\n- Java Collections framework, in the java.util package, supports all basic common manipulations on collections, maps, and basic algorithms on collections, arrays are implemented in two supporting classes Collections, Arrays.\n- Suggestions for choosing a class for managing a group of elements:\n\n| Group characteristics | The class should be chosen |\n|-----------------------|---------------------------|\n| Elements can be duplicated | Java.util.ArrayList |\n| Elements must be distinct and sorted and each operation needs high performance. | Java.util.TreeSet |\n| Each element contains a unique key and operations must have very high performance | Java.util.HashMap |\n\nFor extra operations on collections and arrays such as sorting, copying, etc., refer to classes: java.util.Collections and java.util.Arrays.\n\n## Course Slide\n\n- [Collections.pdf](/resource/Collections.pdf)\n\n## Reading\n\n- [Support Classes.pdf](/resource/Support%20Classes.pdf)\n"
  },
  {
    "id": "DynamicMemorySection",
    "filename": "DynamicMemorySection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/DynamicMemorySection.mdx",
    "title": "Memory Management in Java",
    "frontmatter": {
      "title": "Memory Management in Java",
      "sidebar_label": "Dynamic Memory",
      "sidebar_position": 9,
      "description": "Java memory management, heap, stack, allocation, and garbage collection.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Memory Management in Java\n\n## Static and Dynamic Heap and Stack\n\nIn Java, memory management is the process of allocation and de-allocation of objects. Java does memory management automatically using a garbage collector, so you do not need to implement memory management logic in your application.\n\n- Read more: [Oracle Docs](https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html)\n- Read more: [JavaTpoint](https://www.javatpoint.com/memory-management-in-java)\n\nAllocation happens directly when you create an object with `new` and indirectly when you call a method with local variables or arguments. Local data of a method (return data, parameters, variables) is allocated on the **stack** and discarded when the method exits, but objects are allocated on the **heap** and have a longer lifetime.\n\n### Static and Dynamic Heap and Stack\n\n- **Static heap**: Contains class declarations when classes are loaded. Use the `static` keyword for static methods, variables, classes, and blocks.\n- **Dynamic heap**: The runtime data area for all Java objects and arrays. Created when the JVM starts and may grow/shrink as the application runs. Objects not used become garbage and are de-allocated.\n- **Stack**: Memory for temporary variables and method calls. Each method call creates a new block in the stack for its local values and references. When the method ends, the block is erased.\n\n![Java memory layout](/media/memory.webp)\n\n1. When the program runs, the class definition **Tester** is loaded to static heap.\n2. Running **main** creates stack space for variables `age` and `sc`. `age` is stored directly in stack; `sc` points to a **Scanner** object in heap.\n3. When **main** finishes, its stack space is discarded. `age` and `sc` are killed.\n4. The **Scanner** object in heap still exists and becomes garbage.\n\n![Java memory after main](/media/memory2.webp)\n\n## Dynamic Allocation\n\nExample code:\n\n```java\npublic static void main(String[] args) {\n    int a[] = new int[5];   // [1]\n    String s = new String(\"hello\");  // [2]\n}\n```\n\n- When **main** runs, `a` and `s` are allocated in stack memory as references.\n- At [1], `new` allocates memory in heap for an array of 5 elements and returns its address to `a`.\n- At [2], `new` allocates memory in heap for the string \"hello\" and returns its address to `s`.\n\n![Dynamic allocation](/media/allocation.webp)\n\nTo make a reference point to nothing, use `null`:\n\n```java\nint a[]=null;\nString s=null;\n```\n\n## Dynamic Deallocation\n\nIn Java, you never explicitly free memory. Java provides **automatic garbage collection**. Local variables in a method are allocated when the method runs and deallocated automatically when it terminates. Unused objects in heap memory are deallocated by the Java system.\n\n![Scope and garbage collection](/media/memory3.webp)\n\nWhen the program runs to a certain line, variables may go out of scope and objects become garbage. Setting a reference to `null` also makes the object eligible for garbage collection.\n\n## Garbage Collection\n\nThe JVM supports a garbage collector to free Java programmers from explicitly managing heap memory. It is called by the JVM only and cannot be activated manually. The Java heap is managed by two lists: free block list and allocated block list. After many allocations and de-allocations, memory may become fragmented.\n\n- Read more: [Java Memory Management Whitepaper](https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)\n- Read more: [Garbage Collection in Java](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)\n\nThe runtime system keeps track of allocated memory and determines whether it is still usable. The garbage collector runs only when the system heap becomes exhausted and has the lowest priority. If objects are garbage, they are deallocated automatically.\n\n## Summary\n\n- The memory available to an application at run-time consists of static and dynamic heap and stack\n- Static memory contains class definitions and shared data of the application\n- Java supports dynamic memory for applications at run-time upon request\n- The keyword **new** allocates a region of dynamic memory and returns its starting address\n- We store the address of dynamically allocated memory in the reference variable\n- Deallocation is made by Garbage Collector\n\n## Course Slide\n\n- [Memory Management in Java.pdf](/resource/Memory%20Management%20in%20Java.pdf)\n"
  },
  {
    "id": "EncapsulationSection",
    "filename": "EncapsulationSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/EncapsulationSection.mdx",
    "title": "Encapsulation Section",
    "frontmatter": {
      "title": "Encapsulation Section",
      "sidebar_label": "Encapsulation",
      "sidebar_position": 4,
      "description": "Encapsulation, class structure, constructors, and access modifiers in Java.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Encapsulation\n\n## Class and Object\n\n**Class**\n\nIn the previous topic, we saw the term \"class\" but did not give enough consideration to its meaning. Now we can establish a useful definition:\n\n> A **class** is an organisational unit of an Object Oriented design and program.\n\n[see class definitions on the w3schools page](https://www.w3schools.com/java/java_oop.asp)  \n[see class definitions from other authors](https://open.umn.edu/opentextbooks/textbooks/java-java-java-object-oriented-problem-solving?fbclid=IwAR2_jsAY7ldx2i-178wHimdAkCz0k65ZBVUR7G7OJSNpN3cikA3sPlGQBcQ)\n\n- **Highly cohesive:** the class represents a single useful entity or organisational unit and does that job well.\n- **Minimally coupled:** the class limits its interactions with other classes to only those that are really necessary for it to do what it is designed to do.\n- **Encapsulation:** the class keeps information necessary to its internal operation private and does not expose it to other classes, and only makes public the information.\n\nSo whenever we want to create an OO program, we should give thought to the notion of OO design and think about what classes or entities we need to create, using the principles of high cohesion, low coupling and encapsulation as our guide.\n\nA formal definition of a **class** includes two key components: **Fields(Attributes)** and **Methods(Behaviors)**\n\n> This is a good time to start.\n\n**Problem:** A sports car can be one of a variety of colours, with an engine power between 100 HP and 200 HP. It can be a convertible or a regular model. The car has a button that starts the engine and a parking brake. When the parking brake is released and you press the accelerator, it drives in the direction determined by the transmission setting.\n\n**Design guideline:**\n1. **Looking for main nouns**, classes are often described by main nouns in the problem.\n2. **Looking for auxiliary nouns** that describe details of the main noun, Fields or Attributes are often described by auxiliary nouns.\n3. **Looking for verbs**, methods or behaviors are often described by verbs.\n4. **Find the relationship** among classes. **TIPS**: *If your problem has two main nouns. They have often the relationship.*\n\n![Encapsulation example 1](/media/encapsulation1.webp)\n\nWe use Unified Modeling Language(UML) to describe the class structure. UML provides mechanisms to represent class members, such as attributes and methods, and additional information.\n\n[Read this article to get more about UML>](https://en.wikipedia.org/wiki/Class_diagram)\n\nA UML class diagram is used to represent the Car class\n\n![Encapsulation example 2](/media/encapsulation2.webp)\n\n### How to draw the class structure?\n- put main noun(Car) to make the class name\n- put auxiliary nouns(nouns describe the detail of Car) to make fields\n- put verbs to make methods\n- To specify the visibility of a class member from other classes (i.e. any attribute or method), these notations(-,+,#,~) must be placed before the member's name. (In Java, '~' is replaced by ' '). [get more notations>](https://en.wikipedia.org/wiki/Class_diagram)\n\nNow, You will implement this class in Java. In your editor, create a new file named Car.java (**Note**: the file named the same as the class name). The code of Car class:\n\n```java\npublic class Car {\n    //fields\n    private String Colour;\n    private int EnginePower;\n    private boolean Convertible;\n    private boolean parkingBrake;\n\n    //methods\n    public Car(){\n        Colour=\"\";\n        EnginePower=0;\n        Convertible=false;\n        parkingBrake=false;\n    }\n\n    public Car(String Colour, int EnginePower, boolean Convertible, boolean parkingBrake) {\n        this.Colour = Colour;\n        this.EnginePower = EnginePower;\n        this.Convertible = Convertible;\n        this.parkingBrake = parkingBrake;\n    }\n\n    public void pressStartButton(){\n        System.out.println(\"You can press the star button\");\n    }\n\n    public void pressAcceleratorButton(){\n        System.out.println(\"You can press the accelerator button\");\n        System.out.println(\"Colour:\"+ Colour);\n        System.out.println(\"Engine power:\"+ EnginePower);\n        System.out.println(\"Convertible:\"+ Convertible);\n        System.out.println(\"parking brake:\"+ parkingBrake);\n    }\n\n    public void setColour(String Colour) {\n        this.Colour = Colour;\n    }\n\n    public String getColour() {\n        return Colour;\n    }\n\n    public int getEnginePower() {\n        return EnginePower;\n    }\n\n    public void setEnginePower(int EnginePower) {\n        this.EnginePower = EnginePower;\n    }\n}\n```\n\n![Demo Car Class](/media/demoCarClass.webp)\n![Output Car Class](/media/outputCarClass.webp)\n\n## Constructor\n\nComplete encapsulation requires a mechanism for initializing data members at creation-time. Without initialization at creation-time, an object's data members contain undefined values until client code calls a modifier that sets that data.\n\nThe special member function that any object invokes at creation-time is called its class' constructor.\n\nThe example above, the special method **Car()&#123;...&#125;** is inserted to the file Car.java. It is called the **default constructor**. Therefore, all fields of c or c2 are assigned to empty values. Values are called the **state of object**. Initializing an object's instance variables in a constructor ensures that the object has a well-defined state from the time of its creation.\n\nThe default constructor takes its name from the class itself. The prototype for this no-argument constructor takes the form **ClassName()**\n\n## Overloading Constructor\n\nOverloading a class' constructor adds communication options for client code. Client code can select the most appropriate set of arguments at creation time.\n\n![Encapsulation8](/media/Encapsulation8.webp)\n\nThis method is called the **constructor with parameters**.\n\n![Encapsulation9](/media/encapsulation9.webp)\n\nIn the above code, the third object c3 is created and c3 invokes the constructor with parameters. All fields of c3 are assigned as {\"red\", 100, true, true}.\n\n![Encapsulation10](/media/encapsulation10.webp)\n\nBecause c3 invokes pressAcceleratorButton(), The state of c3 is printed out.\n\n![Encapsulation11](/media/encapsulation11.webp)\n\n**Note**: If the class definition includes the prototype for a constructor with some parameters but does not include the prototype for a no-argument default constructor, the compiler DOES NOT insert an empty-body, no-argument default constructor. The compiler only inserts an empty-body, no-argument default constructor if the class definition does not declare ANY constructor.\n\nAll methods that are implemented in the Car class at the time are called member methods/functions.\n\n## The current Object\n\nWhen run **\"c1.pressAcceleratorButton();\"**, c1 invokes the method => the object (is handled by c1) is the current object at the time.\n\nWhen run **\"c2.pressAcceleratorButton();\"**, c2 invokes the method => the object (is handled by c2) is the current object at the time.\n\n**This**\n\nThe keyword **this** returns the address of the current object. That is, this holds the address of the region of memory that contains all of the data stored in the instance variables of current object.\n\n**Scope of this:** This is created and used just when the member method is called. After the member method terminates **this** will be discarded.\n\n[more](https://www.javatpoint.com/this-keyword)\n\n![Encapsulation12](/media/encapsulation12.webp)\n\nUpon entering the constructor with parameters, the pointer **this** is created by Java and it is storing the address of the object (4000). **c3 and this** are pointing to the current object. Using **this** in here to distinguish local variable and instance variable/field. After assigning values of input parameters to instance variables of c3, **this** will be discarded.\n\n**TIPS**: If parameters (formal arguments) of a member method and instance variables/fields are same. So, we are using this keyword to distinguish local variable and instance variable.\n\n## Member functions\n\nMember functions are the functions, which have their declaration inside the class definition and work on the data members of the class.\n\nAt the time, the Car class contains member functions as:\n\n![Encapsulation13](/media/encapsulation13.webp)\n\nAfter an object is created and assigned default values. Now, if you want to set one instance variable to other value. for example, change only one instance variable colour of c3 to 'black'. What solution for this case?\n\nIt's OK, we will add more a method **setColour()** to the Car class design. The code as:\n\n![Encapsulation14](/media/encapsulation14.webp)\n\nThe main code:\n\n![Encapsulation15](/media/encapsulation15.webp)\n\nthe pointer **c3 invokes setColour(\"black\")**. Therefore, at the time **this.Colour=...** is used to access to instance variable of c3.\n\nThe same above idea, if you want to get the value of one instance variable you should add more a method **getColour()**\n\n![Encapsulation16](/media/encapsulation16.webp)\n\nYou can also add more other getters/setters. The completed code:\n\n```java\npublic class Car {\n    //fields\n    private String Colour;\n    private int EnginePower;\n    private boolean Convertible;\n    private boolean parkingBrake;\n\n    //methods\n    public Car(){\n        Colour=\"\";\n        EnginePower=0;\n        Convertible=false;\n        parkingBrake=false;\n    }\n\n    public Car(String Colour, int EnginePower, boolean Convertible, boolean parkingBrake) {\n        this.Colour = Colour;\n        this.EnginePower = EnginePower;\n        this.Convertible = Convertible;\n        this.parkingBrake = parkingBrake;\n    }\n\n    public void pressStartButton(){\n        System.out.println(\"You can press the star button\");\n    }\n\n    public void pressAcceleratorButton(){\n        System.out.println(\"You can press the accelerator button\");\n        System.out.println(\"Colour:\"+ Colour);\n        System.out.println(\"Engine power:\"+ EnginePower);\n        System.out.println(\"Convertible:\"+ Convertible);\n        System.out.println(\"parking brake:\"+ parkingBrake);\n    }\n\n    public void setColour(String Colour) {\n        this.Colour = Colour;\n    }\n\n    public String getColour() {\n        return Colour;\n    }\n\n    public int getEnginePower() {\n        return EnginePower;\n    }\n\n    public void setEnginePower(int EnginePower) {\n        this.EnginePower = EnginePower;\n    }\n}\n```\n\n**Output:**\n\n```\nYou can press the star button\nYou can press the accelerator button\nColour:\nEngine power:0\nConvertible:false\nparking brake:false\nYou can press the accelerator button\nColour:\nEngine power:0\nConvertible:false\nparking brake:false\nYou can press the accelerator button\nColour:red\nEngine power:100\nConvertible:true\nparking brake:true\nColour of c3:black\n```\n\n**TIPS**: A class often has method four groups. Constructors, getters, setters and other logic methods. Any method that is put in the class will operate on fields in its class.\n\n## Package\n\nA *package* is a namespace that organizes a set of related classes and interfaces. Conceptually you can think of packages as being similar to different folders on your computer.\n\nBecause software written in the Java programming language can be composed of hundreds or thousands of individual classes, it makes sense to keep things organized by placing related classes and interfaces into packages.\n\n[see more at Oracle](https://docs.oracle.com/javase/tutorial/java/concepts/package.html)  \n[see more at other page](https://www.geeksforgeeks.org/packages-in-java/)\n\n### Creating a package\n\nTo create a package, you choose a name for the package and put a package statement with that name at the top of every source file that contains the types (classes, interfaces, enumerations, and annotation types) that you want to include in the package.\n\nThe package statement (for example, *package mypkg;*) must be the first line in the source file. There can be only one package statement in each source file, and it applies to all types in the file.\n\n![Package Example](/media/package.webp)\n\n[read more>](https://docs.oracle.com/javase/tutorial/java/package/createpkgs.html)\n\n## Access Modifier\n\nTo specify the visibility of a class member (i.e. any attribute or method), we use:\n- private: -\n- public: +\n- protected: #\n- default: if don't any notation, it is treated as default\n\nthese keywords are called **access modifier**\n\n![Encapsulation20](/media/encapsulation20.webp)\n\nLet's understand the access modifiers in Java by a simple table.\n\n![Encapsulation21](/media/encapsulation21.webp)\n\n### private\n\nThe private access modifier is accessible only within the class.\n\nWe cut the method main in the file Car.java. Paste it to the other file named Tester.java.\n\n```java\npublic class Tester {\n        public static void main(String[] args) {\n          Car c=new Car();\n          c.pressStartButton();\n          c.pressAcceleratorButton();\n\n          Car c2=new Car();\n          c2.pressAcceleratorButton();\n\n          Car c3=new Car(\"red\", 100, true, true);\n          c3.pressAcceleratorButton();\n          c3.setColour(\"black\");\n          System.out.println(\"Colour of c3:\" + c3.getColour());\n          //access the instance variable Colour of c\n          c.Colour=\"Gray\"; // error\n    }\n}\n```\n\nIn the method main, Using **c.Colour=\"Gray\"** will cause an error because it is private data. Also , all private members can not access from other classes\n\n### public\n\nThe **public** access modifier is accessible everywhere.\n\nIn the above example, the Car class is public to can use it everywhere. In the Tester.java, we can also access to public methods.\n\n### default\n\nIf you don't use any modifier, it is treated as default by default. The default modifier is accessible only within package. It cannot be accessed from outside the package. It provides more accessibility than private. But, it is more restrictive than protected, and public.\n\nEdit the file Car.java\n\n```java\npackage A;\npublic class Car {\n    //fields\n    private String Colour;\n    private int EnginePower;\n    private boolean Convertible;\n    private boolean parkingBrake;\n    //methods\n    public Car(){\n        Colour=\"\";\n        EnginePower=0;\n        Convertible=false;\n        parkingBrake=false;\n    }\n\n    public Car(String Colour, int EnginePower, boolean Convertible, boolean parkingBrake) {\n        this.Colour = Colour;\n        this.EnginePower = EnginePower;\n        this.Convertible = Convertible;\n        this.parkingBrake = parkingBrake;\n    }\n\n    void pressStartButton(){\n        System.out.println(\"You can press the star button\");\n    }\n}\n```\n\nEdit the file Tester.java\n\n```java\npackage B;\nimport A.Car;\npublic class Tester {\n        public static void main(String[] args) {\n          Car c=new Car();\n          c.pressStartButton();        // error\n          c.pressAcceleratorButton();\n\n          Car c2=new Car();\n          c2.pressAcceleratorButton();\n\n          Car c3=new Car(\"red\", 100, true, true);\n          c3.pressAcceleratorButton();\n          c3.setColour(\"black\");\n          System.out.println(\"Colour of c3:\" + c3.getColour());\n    }\n}\n```\n\nBecause the method **pressStartButton()** is default, in the method main we can not invoke this.\n\n### protected\n\nThe protected access modifier is accessible within package and outside the package but through inheritance only.\n\n## Summary\n\n- Encapsulation is a way of packaging data and methods together into one unit. [more](https://www.w3schools.in/java-tutorial/encapsulation)\n- To achieve encapsulation, declare fields as private\n- Provide public get and set methods to access and update the value of a private variable\n- The constructor is a special member function that an object invokes at creation time, the name of the constructor is the name of the class, not have return types\n- The compiler inserts an empty body constructor into any class definition that does not declare a constructor\n- The current values are storing in instance variables of a object is called the state\n\n## Course Slide\n\n- [Encapsulation.pdf](/resource/Encapsulation.pdf)\n"
  },
  {
    "id": "ExceptionSection",
    "filename": "ExceptionSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/ExceptionSection.mdx",
    "title": "Exception Handling",
    "frontmatter": {
      "title": "Exception Handling",
      "sidebar_label": "Exception Handling",
      "sidebar_position": 10,
      "description": "Understanding exceptions in Java: types, handling, and best practices.",
      "tags": [
        "Key Concepts",
        "Java",
        "Exceptions"
      ]
    },
    "content": "\n# Exception Handling\n\n## What Is an Exception\n\nAn exception is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions.\n\nWhen an error occurs within a method, the method creates an object and hands it off to the runtime system. The object, called an exception object, contains information about the error, including its type and the state of the program when the error occurred. Creating an exception object and handing it to the runtime system is called **throwing an exception**.  \n[See Oracle Docs for details](http://docs.oracle.com/javase/tutorial/essential/exceptions/index.html)\n\nFor example:\n- A user might type an invalid filename\n- An accessed file does not exist or might contain corrupted data\n- A network link could fail\n- ...\n\nCircumstances of this type are called exception conditions in Java and are represented using objects (all exceptions descend from `java.lang.Throwable`).\n\nConsider the code that causes an exception:\n\n![Exception code example](../../../../public/media/exception.webp)\n\nAt line 4, the `main` method causes an error and creates an exception object of type `ArithmeticException`. The JVM throws it to the `main` method. Because `main` does nothing to control this error, the output looks like this. When the error occurs at line 4, the statement at line 5 is skipped.\n\n## Kinds of Exception\n\n### Checked exception\n\nChecked exceptions are checked at compile time. You must handle them by either the try-catch mechanism or the throws-declaration mechanism.\n\n*For example:*\n\n![Checked exception example](../../../../public/media/exception2.webp)\n\nIn the above example, the method `FileReader()` is throwing an exception. You must use try-catch or throws to handle it.\n\n### Unchecked exception\n\nAn unchecked exception occurs at runtime. These are also called Runtime Exceptions. The program won’t give a compilation error. Most of the time, these exceptions occur due to bad data provided by the user during interaction.\n\n*For example:*\n\n![Unchecked exception example](../../../../public/media/exception1.webp)\n\nIf you declare an array of size 5 and try to access the 6th element, an error occurs.\n\n[See more details](https://stackify.com/types-of-exceptions-java/)\n\n## How to fix\n\nWe can use try-catch or throws mechanisms to handle and avoid these errors.\n\n### try-catch mechanism\n\nConsider the flow and syntax:\n\n![Try-catch syntax](../../../../public/media/exception3.webp)\n\nThe `try` statement allows you to define a block of code to be tested for errors while it is being executed.\n\nThe `catch` statement allows you to define a block of code to be executed if an error occurs in the try block.\n\nThe `finally` statement lets you execute code after try...catch, regardless of the result.\n\n:::note\nYou cannot use `finally` without a `try` block. The `finally` block is optional.\n:::\n\nIn the example **DemoException2**, we will edit:\n\n![DemoException2 example](../../../../public/media/exception5.webp)\n\nWhen the program runs to line 14, if the file name \"computer.txt\" does not exist, an exception object of type `FileNotFoundException` is created by `main` and thrown to the catch block. The variable `e` stores the address of the object. In the catch block, you can use `e` to get error information.\n\n**The Output will be:**\n\n```\nsomething are wrong\ntry-catch is finished\n```\n\nIn the example **ExceptionDemo_1**, we will edit:\n\n![ExceptionDemo_1 example](../../../../public/media/exception4.webp)\n\nWhen you try to get the 6th element, an exception object of type `ArrayIndexOutOfBoundsException` is created. The JVM throws the object to the catch block.\n\n**The output will be:**\n\n```\n1,2,3,4,5,something are wrong\ntry-catch is finished\n```\n\n### throws mechanism\n\nIn the example **DemoException2**, the error occurs in `main`. To fix a checked exception, we use the `throws` keyword. We will edit:\n\n![throws mechanism example](../../../../public/media/exception6.webp)\n\n**The output will be:** something are wrong if the file name \"computer.txt\" does not exist.\n\n## Examples\n\nThe code below prints out \"age is 20 or older\" if age is below 20 or if you input text:\n\n![Age example code](../../../../public/media/exception7.webp)\n\nWhen the code runs to line 20, if you input text \"hello\", an exception object is created and thrown to the catch block. The output will be:\n\n![Output for hello input](../../../../public/media/exception8.webp)\n\nIf you input 18, the statement `throw new Exception()` creates an exception object, which is thrown to the catch block. The output will be:\n\n![Output for 18 input](../../../../public/media/exception9.webp)\n\n## Summary\n\n- A try block is always followed by a catch block, which handles the exception that occurs in the associated try block.\n- A single try block can have multiple catch blocks. See [catching multiple exceptions in Java](https://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html).\n- A try statement may be nested inside either the try or catch block of another try statement. See [Nesting of try/catch Blocks](https://beginnersbook.com/2013/04/nested-try-catch/#:~:text=When%20a%20try%20catch%20block,that%20that%20catch%20block%20executes.).\n- When you write a method that causes an exception, if you do not want to handle this error you can throw it to another method using the `throws` keyword.\n- You can create your own exception classes. See [Custom Exception Classes](https://www.javatpoint.com/custom-exception).\n\n## Course slide\n\n- [Exceptions.pdf](../../../../public/resource/Exception%20Handling.pdf)\n\n## Workshop\n\n- Complete the [workshop2](../../../../public/workshop/workshop2.pdf)\n"
  },
  {
    "id": "FileIOSection",
    "filename": "FileIOSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/FileIOSection.mdx",
    "title": "File Input and Output",
    "frontmatter": {
      "title": "File Input and Output",
      "sidebar_label": "File I/O",
      "sidebar_position": 11,
      "description": "Java basics for standard input/output and file reading using streams and Scanner.",
      "tags": [
        "Key Concepts",
        "Java",
        "File IO"
      ]
    },
    "content": "\n# Standard Input and Output\n\nThis topic covers the Java platform classes used for basic input and output. It focuses primarily on I/O Streams, a powerful concept that greatly simplifies I/O operations.\n\n## I/O Stream\n\nAn I/O Stream represents an input source or an output destination. A stream can represent many different kinds of sources and destinations, including disk files, devices, other programs, and memory arrays.\n\nStreams support many different kinds of data, including simple bytes, primitive data types, localized characters, and objects. Some streams simply pass on data; others manipulate and transform the data in useful ways.\n\n*For more details, see the [Java I/O Streams documentation](https://docs.oracle.com/javase/tutorial/essential/io/streams.html).*\n\n## I/O from the Command Line\n\nA program is often run from the command line and interacts with the user in the command line environment. The Java platform supports this kind of interaction in two ways: through the Standard Streams and through the Console.\n\nThe Java platform supports three Standard Streams:\n- **Standard Input**: accessed through `System.in`\n- **Standard Output**: accessed through `System.out`\n- **Standard Error**: accessed through `System.err`\n\nThese objects are defined automatically and do not need to be opened. Standard Output and Standard Error are both for output; having error output separately allows the user to divert regular output to a file and still be able to read error messages. For more information, refer to the [documentation for your command line interpreter](https://docs.oracle.com/javase/tutorial/essential/io/cl.html).\n\nTo get user input, we can also use the `Scanner` class. *[See more about Scanner](https://docs.oracle.com/javase/tutorial/essential/io/scanning.html).* This class supports methods to get various types from the user:\n\n| Method         | Description                        |\n| -------------- | ---------------------------------- |\n| nextBoolean()  | Reads a boolean value from the user |\n| nextByte()     | Reads a byte value from the user    |\n| nextDouble()   | Reads a double value from the user  |\n| nextFloat()    | Reads a float value from the user   |\n| nextInt()      | Reads an int value from the user    |\n| nextLine()     | Reads a String value from the user  |\n| nextLong()     | Reads a long value from the user    |\n| nextShort()    | Reads a short value from the user   |\n\n## Example\n\n![Java I/O Example](../../../../public/media/ioexample.webp)\n\nIn the above example, we need to import the library class `Scanner` from the package `java.util.Scanner`. At line 10, we declare the variable `sc` and create an object from this class. At line 11, a message \"Enter number of elements\" is printed. At line 12, the statement `sc.nextLine()` gets a string from the user, and then we use `Integer.parseInt()` to convert the inputted string to an integer value. At line 19, `System.out.format` is used in Java to format output.\n\n## Summary\n\n- The easiest way to get user data is to use the library class `Scanner`.\n- Use `System.out` to print data to the console.\n- Convert a string to a number using classes like `Integer`, `Float`, etc.\n\n# Reading from a File\n\n```java\ntry (BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"))) {\n    String line;\n    while ((line = br.readLine()) != null) {\n        System.out.println(line);\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n"
  },
  {
    "id": "FoundationsCourseSection",
    "filename": "FoundationsCourseSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/FoundationsCourseSection.mdx",
    "title": "Foundations Course Section",
    "frontmatter": {
      "title": "Foundations Course Section",
      "sidebar_label": "Foundations",
      "sidebar_position": 3,
      "description": "Java Virtual Machine, data types, arrays, and basic Java concepts.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Foundations\n\n## Java Virtual Machine\n\nThe Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.  \n[See Wiki for a detailed exposition](http://en.wikipedia.org/wiki/Java_virtual_machine).\n\n![Java Virtual Machine](/media/JVM.webp)\n\n## Platform Independence\n\nThe key that allowed Java to solve both the security and the portability problems is that the output of a Java compiler is not executable code. Rather, it is ByteCode - a highly optimized set of instructions designed to be executed by the Java run-time system, which is called the Java Virtual Machine (JVM).\n\n## Demo: First Program\n\nSteps:\n1. Create a new Java NetBeans project\n2. Add a Java class\n3. Write code\n4. Compile/Run the program\n\n![First Java Program](/media/firstProgram.webp)\n![Step 2](/media/step2.webp)\n![Step 2.2](/media/step22.webp)\n![Step 3](/media/step3.webp)\n![Step 4](/media/step4.webp)\n\n## Keywords and Identifiers\n\nKeywords: Almost all of them are similar to those in C language.\n\n![Keywords](/media/keyword.webp)\n\n## Data Types\n\nJava is a strongly typed language. Following are the data types and their declarations.\n\n**Declaration:**\n\n```java\nType var [=Initial value];\n```\n\n```java\nint RollID;\nchar type='A';\n```\n\n![Primary Data Types](/media/PrimaryDataType.webp)\n\n#### Reference Type\n\nFollowing are the reference types in Java:\n- array\n- class object\n- interface\n\n```java\nint[] ar;\nar= new int[3];\nar[0]=1; ar[1]=2; ar[2]=3;\n```\n\n![Reference Data Types](/media/referenceDataType.webp)\n![Array](/media/array.webp)\n\n## Scope\n\nThe scope of a declaration is the portion of a program over which that declaration is visible. Scopes include:\n- function scope - visible to the source code within the function\n- class scope - visible to the member functions of the class\n- block scope - visible to the code block\n- global scope - visible to the entire program\n- file scope - visible to the source code within the file\n\nThe scope of a non-global declaration begins at the declaration and ends at the closing brace for that declaration. A non-global declaration is called a local declaration.\n\n## One Dimensional Arrays\n\nAn array is a container object that holds a fixed number of values of a single type.  \nThe length of an array is established when the array is created.  \nEach item in an array is called an element, and each element is accessed by its numerical index.\n\n![One Dimensional Array](/media/array2.webp)\n\n```java\nint[] ar;  // for detail click here\nfloat anArrayOfFloats[];\n```\n\n## Multiple Dimensional Arrays\n\nConsider the example:\n\n![2D Array Code](/media/2DarrayCode.webp)\n\nThis is a sample memory map of the above code:\n\n![2D Array Memory Map](/media/2Darray.webp)\n\nWe have created a multidimensional array named *m*, it holds 8 elements. The variable m is storing the value: *8000* that is the address of an array. m can be seen as an array of one–dimensional array.  \nIn the above example, the statement: m[1]=replacement to assign 1000 to m at index 1.  \nNow, the m can hold 12 elements.  \noutput: *1,2,3,4,5,6,7,8,9,10,2001,2002*\n\n## Operators\n\n![Operators](/media/operator.webp)\n![Operators 2](/media/operator2.webp)\n![Operators 3](/media/operator3.webp)\n\n## Logic constructs\n\nThe statements inside your source files are generally executed from top to bottom, in the order that they appear. Control flow statements, however, break up the flow of execution by employing decision making, looping, and branching, enabling your program to conditionally execute particular blocks of code. This section describes the decision-making statements (if-then, if-then-else, switch), the looping statements (for, while, do-while), and the branching statements (break, continue, return) supported by the Java programming language.\n\n- [if statement](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/if.html) [for detail]\n- [switch statement](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html) [for detail]\n- [while, do, for statements](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html) [for detail]\n\n## Summary\n\n- a declaration associates an identifier with a type\n- a definition attaches meaning to an identifier and is an executable statement\n- the scope of a declaration is that part of the program throughout which the declaration is visible\n- The types of the Java are primitive types and reference types\n\n## Course Slide\n\n- [Learning the Java Language.pdf](/resource/Learning%20the%20Java%20Language.pdf)\n\n## Reading\n\n- [Download & Install JDK & NetBeans 8.pdf](/resource/Download%20&%20Install%20JDK%20&%20NetBeans%208.pdf)\n- [Get Start.pdf](/resource/Get%20start.pdf)\n- [Numbers and Strings.pdf](/resource/Numbers%20and%20Strings.pdf)\n"
  },
  {
    "id": "InheritanceSection",
    "filename": "InheritanceSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/InheritanceSection.mdx",
    "title": "Inheritance Section",
    "frontmatter": {
      "title": "Inheritance Section",
      "sidebar_label": "Inheritance",
      "sidebar_position": 5,
      "description": "Inheritance, class hierarchies, constructors, and type checking in Java.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Inheritance\n\n## Definition\n\nObject-oriented languages implement reusability of coding structure through inheritance. Inheritance is the second most prominent concept next to encapsulation. It refers to the relationship between classes where one class inherits the entire structure of another class. Inheritance is naturally hierarchical, a tighter relationship than composition and the most highly coupled relationship after friendship.\n\n### Hierarchies in the Real World\n\nFor example, the staffing structures in traditional human resource management, with a CEO at the top of the structure, deputies and senior managers beneath that, followed by team leaders and workers. Such structures are useful in making the day to day operations of an organisation manageable. In a retail shop, products are organised and managed in thematic grouping such as hard goods, perishable foods and so on. Such groupings form an integral part of the stock control and checkout management operations. We often use tree diagrams and organograms to capture and visualise these relationships. For example, for the retail shop example:\n\n[reference](references.html) | [other definitions](https://howtodoinjava.com/java/oops/java-inheritance/)\n\n![Inheritance Example 1](/media/inheritance1.webp)\n\nIn the context of OO design, we are interested in hierarchies that represent the progressive design of a set of classes. The root of our design is a relatively abstract entity, and we build upon that entity to produce progressively more concrete entities. Considering our previous example closer up\n\n![Inheritance Example 2](/media/inheritance2.webp)\n\nWe note that the entity of an Item is relatively abstract in the sense that we could not go into a shop and purchase one. If we said to a member of staff that we “wish to purchase an item”, we would expect the response “which item?”. We can purchase specific, or concrete entities, but not those that are relatively abstract in their conceptualisation. But that does not mean that the higher-level entities have no value. They just serve as base definitions onto which we can build more concrete entities. We say that that the higher-level entities are **“parent”, “base” or “super”** classes, and the lower-level ones built from them are **“child”, \"derived\" or “sub”** classes.\n\n## \"is-a\" relationship\n\nThe key idea here is the **“is-a”** relationship. Looking at our shop example, we see that **HardGood is-a Item** and that **ElectricalGood is-a HardGood** and by extension is-a Item. That suggests that, in type terms, ElectricalGood has type ElectricalGood and also has type of HardGood and ultimately Item. This is the kind of hierarchical relationship that Java and other OO programs are designed to capture.\n\nNot every real-world hierarchy as we might construe it is suited to this kind of super and sub class analysis. Consider the human resources example referred to earlier. The CEO is the head of the organisation, but does not make much sense as a base class. A senior manager is not also the CEO. A team member is not also a senior manager. So instead of the classic staffing organogram that you might be used to seeing, a more appropriate OO relationship might look something like this:\n\n![Inheritance Example 3](/media/inheritance3.webp)\n\nSuch an OO compatible hierarchical relationship is an example of the key OO concept of “polymorphism”.\n\n**Polymorphism** at the class level is the concept that an object can take on more than one form. If an object of class type X has a parent class of type Y, then X can take the form of an object of type either X or Y, and can thus appear in many forms.\n\n## Derived and Super Classes\n\nIn OO design terms we need to consider what attributes and methods a set of classes share. Where we can identify common attributes and methods, we can factorise the design of those classes so that the commonly shared attributes and methods form part of the super class.\n\nWe will use an example to help us understand how this works. Consider a shop that sells antiques items, namely **vases**, **statues and paintings**. For now we shall consider just some appropriate attributes for our initial OO analysis:\n\n![Inheritance Example 4](/media/inheritance4.webp)\n\nWe will make three classes for each of the things that our shop sells. We can see that the classes have some attributes in common, and some that are unique to each class. But we can also see that in reality all three classes are examples of **“items”** — things that the shop sells. So we can factorise our design with an **Item superclass**, and then make our **three specific classes a sub class** of that super class. This is beneficial as it reduces un-necessary code duplication (as well as being a better model of a real-world problem).The super and sub class relationship is represented by an arrow pointing from the sub class towards its super class:\n\n![Inheritance Example 5](/media/inheritance5.webp)\n\nTo implement the \"is-a\" relationship of the above class diagram, we use the keyword **\"extends\"**\n\nAssume that, these classes are stored in the same package\n\n```java\npublic class Item\n{ \n     int value;\n     String creator;\n\n    //The below is methods that you need to implement\n    //default constructor\n    public Item(){\n         value=0;\n         creator=\"\";\n     }\n     //constructor with parameters\n     public Item(int value, String creator){\n         this.value=value;\n         this.creator=creator;\n     }\n    //getter\n    //setter\n    //other logic methods\n} \n```\n\n```java\npublic class Vase extends Item\n{ \n     int height;\n     String material;\n\n    //The below is methods that you need to implement\n    //constructors \n    //getter\n    //setter\n    //other logic methods\n} \n```\n\n```java\npublic class Statue extends Item\n{ \n     int weight;\n     String colour;\n\n    //The below is methods that you need to implement\n    //constructors \n    //getter\n    //setter\n    //other logic methods\n} \n```\n\n```java\npublic class Painting extends Item\n{ \n     int height;\n     int width;\n     boolean isWatercolour;\n     boolean isFramed;\n\n    //The below is methods that you need to implement\n    //constructors \n    //getter\n    //setter\n    //other logic methods\n} \n```\n\n## AntiqueShop Example\n\nThe *Vase* class has a total of **four** attributes. Two of these are unique to it, and two are “inherited” from its superclass. Similarly, the *Painting* class has **six** attributes, four unique to it, and two inherited from its superclass. So a super, base or parent class contains a basic set of attributes that are intended to form a part of the implementation of sub classes that are built from it. The sub classes have their own attributes that make them unique, and they inherit attributes from their superclass.\n\nNow, you create the file named \"AntiqueShop.java\", the method main is in here\n\n```java\npublic class AntiqueShop\n{ \n    public static void main(String[] args){\n\n        Vase v1 = new Vase();\n        v1.value = 100;\n        v1.creator=\"Test1\";\n        // you can assign values to other attributies of v1\n        v1.height=100;\n        v1.material=\"wood\";\n        // this code only uses to check v1's  fields\n\n        Statue s1=new Statue();\n        s1.value=200;\n        s1.creator=\"Test2\";\n        // you can assign values to other attributies of s1\n        s1.weight=100;\n        s1.colour=\"blue\";\n        // this code only uses to check s1's  fields\n\n        Painting p1=new Painting();\n        p1.value=300;\n        p1.creator=\"Test3\";\n        // you can assign values to other attributies of p1\n        p1.height=200;\n        p1.width=100;\n        p1.isWatercolour=true;\n        p1.isFramed=true;\n        // this code only uses to check p1's  fields\n    } \n} \n```\n\n## Functions in Inheritance\n\nWe create three objects v1,s1,p1 from three subclasses. These objects have \"inherited\" attributes\n\nSimilarly, we add a method to the super class Item, it is also inherited in three sub classes. we are able to call those inherited methods as if they had been defined in their own class definitions. For example, we add the method \"output()\" to the Item class.\n\n```java\npublic class Item\n{ \n    public int value;\n    public String creator;\n\n    //The below is methods that you need to implement\n    //constructors \n    //getter\n    //setter\n    public void output(){\n        System.out.println(\"This item is worth \" + value + \" pounds\");\n        System.out.println(\"This item is created by \" + creator );\n    }\n} \n```\n\nEdit the method main:\n\n```java\npublic class AntiqueShop\n{ \n    public static void main(String[] args){\n\n        Vase v1 = new Vase();\n        v1.value = 100;\n        v1.creator=\"Test1\";\n        v1.output();\n\n        Statue s1=new Statue();\n        s1.value=200;\n        s1.creator=\"Test2\";\n        s1.output();\n\n        Painting p1=new Painting();\n        p1.value=300;\n        p1.creator=\"Test3\";\n        p1.output();    \n    } \n} \n```\n\n**Output:**\n```\nThis item is worth 100 pounds\nThis item is created by Test1\nThis item is worth 200 pounds\nThis item is created by Test2\nThis item is worth 300 pounds\nThis item is created by Test3\n```\n\nNote that, for now, all the attributes and methods have been declared as **public**. This is not necessarily good OO design practice and we need to apply the principle of encapsulation. This suggests that attributes of super class are **protected**.\n\nThe rules that govern how we can guarantee inheritance are as follows:\n- **private**: attributes and methods are only accessible from within the class itself, and are not guaranteed to be available in any class extended from it.\n- **protected**: attributes and methods that are private and only available from within the class itself and any class extended from it.\n- **public**: attributes and methods that are accessible from within the class and from any other class or calling code.\n\n## Adding Constructors\n\nWe now know that inheritance allows sub classes to inherit attributes and methods from a super class. We now consider how we should build constructor methods so that instances of our sub classes are created in the most efficient manner.\n\nConsider the constructors is added to the Vase class.\n\n```java\npublic class Vase extends Item\n{ \n    private int height;\n    private String material;\n\n    //The below is methods that you need to implement\n    public Vase(){    \n         value=0;\n         creator=\"\";\n         height=0;\n         material=\"\";\n    }\n    public Vase(int value, String creator, int height, String material){\n         this.value=value;\n         this.creator=creator;\n         this.height=height;\n         this.material=material;\n    }\n} \n```\n\nBecause the Vase class has four fields, you can implement constructors that look like the above. But, that is not efficient coding. It would involve code duplication\n\nTo reduce code duplication, common fields are initialized by using constructors of the superclass.\n\nWe edit the code of the Vase class as follows:\n\n```java\npublic class Vase extends Item\n{ \n    private int height;\n    private String material;\n\n    //The below is methods that you need to implement\n    public Vase(){    \n        super(); //call the default constructor of the Item class\n        height=0;\n        material=\"\";\n    }\n    public Vase(int value, String creator, int height, String material){\n        super(value, creator);  //call the constructor with 2 parameters of the Item class\n        this.height=height;\n        this.material=material;\n    }\n} \n```\n\nThe **super** keyword refers to the super class\n\n> **Note**: Where a sub class is to call a constructor in its parent class using the super() method call, it must be so as the first line of its own constructor. This is to ensure that objects are constructed from their most distant super class first.\n\n> **Note**: A derived class does **not inherit a superclass constructor by default**\n\n> **Note**: If a constructor *does not explicitly invoke a superclass constructor*, the Java compiler *automatically inserts a call to the no-argument constructor of the superclass*. If the super class does not have a no-argument constructor, you will get a compile-time error. Object does have such a constructor, so if Object is the only superclass, there is no problem.\n\nSimilarly, we add constructors to other sub classes\n\nWe use the Java keyword **super** as the qualifier for calling a superclass method:  \n**super.methodName(arguments);**\n\nfor example:\n\n```java\npublic class Item{\n     ...\n     void displayDiscount(){  System.out.println(\"discounting ...\");}  \n}  \npublic class Vase extends Item{  \n    ...\n    @Override\n    void displayDiscount(){\n           super.displayDiscount();\n           System.out.println(\"and taking ...\");\n    }\n    public static void main(String[] args){\n\n        Vase obj=new Vase();\n        obj.displayDiscount();\n    }  \n}\n```\n\nIn a Vase subclass, The \"displayDiscount\" method has the same signature (name, plus the number and the type of its parameters) and return type as in the superclass. It is called the override the superclass's method. We will learn the override method in the next topic\n\nWhenever we wish to invoke the version of super's methods (for example \"displayDiscount\") that was defined by our superclass. We use the **\"super\"** keyword\n\n**Output:**\n```\ndiscounting ...\nand taking ...\n```\n\n**Hidden methods**: Re-implementing a static method implemented in super class\n\n![Hidden Method](/media/hidden%20method.webp)\n\n## Using instanceof operator\n\nConsider the code in the file AntiqueShop.java:\n\n```java\npublic class AntiqueShop\n{ \n    public static void main(String[] args){\n\n        Vase v1 = new Vase(100,\"Paris\",200,\"rock\");  \n        Statue s1= new Statue(200,\"VN\", 1000,\"white\");\n        Painting p1=new Painting(300,\"USA\",2000,1500,true,true);\n\n        Item tmp=v1;  \n    } \n} \n```\n\nIn the above code, we create three objects v1, s1, p1 and initialize values by the constructor with parameters. And then, a reference variable tmp that has the type to be the Item superclass. It is storing the address of object v1. See the figure below:\n\n![Inheritance Example 6](/media/inheritance6.webp)\n\n**dynamic type**: A reference variable that has the type of the superclass can store the address of the object of sub class. It is called to be *dynamic type*, the type that is has at runtime.\n\n**static type**: the type that it has when first declared. Static type checking is enforced by the compiler.\n\nSimilarly, we can use the variable tmp to store the address of objects s1, p1.\n\nHow to check the tmp variable is pointing to the address of a specified object?\n\nUsing the **instanceof** keyword. [read more](https://www.javatpoint.com/downcasting-with-instanceof-operator)\n\nConsider the code:\n\n```java\npublic class AntiqueShop\n{ \n    public static void main(String[] args){\n\n        Vase v1 = new Vase(100,\"Paris\",200,\"rock\");  \n        Statue s1= new Statue(200,\"VN\", 1000,\"white\");\n        Painting p1=new Painting(300,\"USA\",2000,1500,true,true);\n        Item tmp=v1;\n        if(tmp instanceof Vase)\n            System.out.println(\"tmp is pointing to the Vase object\");\n        else if(tmp instanceof Statue)\n            System.out.println(\"tmp is pointing to the Statue object\");\n        else\n            System.out.println(\"tmp is pointing to the Painting object\");    \n    } \n} \n```\n\n**Output:**\n```\ntmp is pointing to the Vase object\n```\n\nThe instanceof operator will return true or false. In the above example, Because the variable tmp is pointing to the Vase object, the instruction \"tmp instanceof Vase\" returns true.\n\n## Casting\n\nNow, we add a method \"putFlowers()\" to the Vase class\n\n```java\npublic class Vase extends Item\n{ \n    private int height;\n    private String material;\n\n    //The below is methods that you need to implement\n    public Vase(){    \n         super();\n         height=0;\n         material=\"\";\n    }\n    public Vase(int value, String creator, int height, String material){\n         super(value, creator);\n         this.height=height;\n         this.material=material;\n    }\n    public void putFlowers(){\n          System.out.println(\"flowers are put in the vase\");\n    }\n} \n```\n\nIn the method main, we edit\n\n```java\npublic class AntiqueShop\n{ \n    public static void main(String[] args){\n\n        Vase v1 = new Vase(100,\"Paris\",200,\"rock\");  \n        Statue s1= new Statue(200,\"VN\", 1000,\"white\");\n        Painting p1=new Painting(300,\"USA\",2000,1500,true,true);\n        Item tmp=v1;\n        if(tmp instanceof Vase){\n            System.out.println(\"tmp is pointing to the Vase object\");\n            ((Vase)tmp).putFlowers();\n        }\n        else if(tmp instanceof Statue)\n            System.out.println(\"tmp is pointing to the Statue object\");\n        else\n            System.out.println(\"tmp is pointing to the Painting object\");\n    } \n} \n```\n\nThe *tmp* variable that has the type of the superclass only calls methods of the superclass. To call methods of the subclass we must *cast explicitly*. If the code has attempted to cast an object to a subclass of which it is not an instance then a *ClassCastException* error will be thrown. For example,\n\n```java\n...\nSystem.out.println(\"tmp is pointing to the Vase object\");\n((Statue)tmp).setColour(\"Gray\"); // causes an error\n...\n```\n\n> **Note**: In Java, The Object class is the parent class of all the classes by default.\n\n## Summary\n\n- Object-oriented languages implement reusability of coding structure through inheritance\n- A derived class does not by default inherit the constructor of a super class\n- Constructors in an inheritance hierarchy execute in order from the super class to the derived class\n- Using the instanceof keyword if we need to check the type of the reference variable.\n- Check the type of the reference variable before casting it explicitly.\n\n## Course Slide\n\n- [Inheritance.pdf](/resource/Inheritance.pdf)\n"
  },
  {
    "id": "IntroductionCourseSection",
    "filename": "IntroductionCourseSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/IntroductionCourseSection.mdx",
    "title": "Introduction to Object-Oriented Programming",
    "frontmatter": {
      "title": "Introduction to Object-Oriented Programming",
      "sidebar_label": "OOP Introduction",
      "sidebar_position": 1,
      "description": "Overview of object-oriented programming concepts: abstraction, encapsulation, inheritance, and polymorphism.",
      "tags": [
        "Key Concepts",
        "Java",
        "OOP"
      ]
    },
    "content": "\n# Welcome to Object-Oriented\n\n## A Language for Complex Applications\n\nModern software applications are *intricate*, *dynamic*, and *complex*. The number of lines of code can exceed hundreds of thousands or millions. These applications evolve over time, sometimes taking years of programming effort to mature. Creating such applications involves many developers with different levels of expertise. Their work consists of smaller, stand-alone, and testable sub-projects—sub-projects that are transferrable, practical, upgradeable, and possibly even usable within other future applications. The principles of software engineering suggest that each component should be **highly cohesive** and that the collection of components should be **loosely coupled**. Object-oriented languages provide the tools for implementing these principles.\n\n## COMPLEXITY\n\nLarge applications are complex. We address their complexity by identifying the most important features of the problem domain; that is, the area of expertise that needs to be examined to solve the problem. We express the features in terms of **data** and **activities**. We identify the data objects and the activities on those objects as complementary tasks.\n\nConsider a course enrollment system for a program in a college or university. Each participant:\n- enrolls in several face-to-face courses\n- enrolls in several hybrid courses\n- earns a grade in each course\n\nThe following structure diagram identifies the activities:\n\n![Algorithmic structure diagram](../../../../public/media/algorithmic.webp)\n\nIf we switch our attention to the objects involved, we find a Course and a Hybrid Course. Focusing on a Course, we observe that it has a Course Code. We look up the Code in the institution's Calendar to determine when that Course is offered.\n\nWe say that a Course has a Code and uses a Grading Scheme and that a Hybrid Course is a kind of Course. The diagram below shows these relationships between the objects in this problem domain. The connectors identify the types of relationships. The closed circle connector identifies a *has-a* relationship, the open circle connector identifies a *uses-a* relationship, and the arrow connector identifies an *is-a-kind-of* relationship.\n\n![Class relationships diagram](../../../../public/media/class_relationships.webp)\n\nIn switching our attention from the activities in the structure chart to the objects in the relationship diagram, we have switched from a procedural description of the problem to an object-oriented description.\n\nThese two complementary approaches to mastering complexity date at least as far back as the ancient Greeks. Heraclitus viewed the world in **terms of process**, while Democritus viewed the world in **terms of discrete atoms**.\n\nLearning to divide a complex problem into objects and to identify the relationships amongst the objects is the subject matter of system analysis and design courses. The material covered in this course introduces some of the principal concepts of analysis and design along with the Java syntax for implementing these concepts in code.\n\n## Object Terminology\n\nIntroduce objects and classes, encapsulation, inheritance, and polymorphism.\n\nObject-oriented programming reflects the way in which we manage day-to-day tasks. Professor Miller of Princeton University demonstrated that most of us can only comprehend about seven chunks of information at a time. As children, we learn to play with small sets of chunks at an early age. As we grow, we learn to break down the problems that we face into sets of manageable chunks.\n\nA chunk in object-oriented programming is called an **object**. The shared structure of a set of similar objects is called their **class**. This shared structure includes the structure of the data in the similar objects as well as the logic that works on that data.\n\nThis chapter introduces the concepts of object, class, encapsulation, inheritance, and polymorphism. Subsequent chapters elaborate on each concept in detail.\n\n## ABSTRACTION\n\nProgramming solutions to application problems consist of components. The process of designing these solutions involves abstraction. In the C programming language, we abstract common code, store it in a structure or function, and refer to that structure or function from possibly multiple places in our source code, thereby avoiding code duplication.\n\nAn object-oriented programming solution to an application problem consists of components called objects. The process of designing an object-oriented solution likewise involves abstraction. We distinguish the most important features of the object, identify them publicly, and hide the less important details within the object itself.\n\n![Abstraction diagram](../../../../public/media/abstraction.webp)\n\nEach object has a crisp conceptual boundary and acts in ways appropriate to itself. Compare a book with a set of notes. A book has pages that are bound and can be flipped. The page order is fixed. A set of notes consists of loose pages that can be rearranged in any order. We represent the book as an object and the set of notes as another object; each object has a different structure.\n\n*Example:*\n- An ear cannot see, an eye cannot listen, and a mouth cannot smell.\n- A horse cannot bark and a dog cannot croak.\n\n## CLASSES\n\nWe describe the structure of similar objects in terms of their class. Objects of the same class have the same structure, but possibly different states. The variable types that describe their states are identical, but generally have different values. For example, all of the books in the figure above have a title and an author, but each book has a different title and a different author.\n\n![Classes diagram](../../../../public/media/classes.webp)\n\nWe say that each object is an instance of its class.\n\n## UML\n\nThe Unified Modelling Language (UML) is a general-purpose modeling language developed for describing systems of objects and relationships between their classes. This language defines standard symbols for classes and their relationships.\n\n![Class relationships diagram](../../../../public/media/class_relationships.webp)\n\n## The Class Diagram\n\nThe primary graphic in UML is the class diagram: a rectangular box with three compartments:\n\n1. the upper compartment identifies the class by its name\n2. the middle compartment identifies the names and types of its attributes and visibility\n3. the lower compartment identifies the names, return types, and parameter types of its operations\n\nwhere visibility is one of:\n- '+': public\n- '-': private\n- '#': protected\n- ' ': default (package)\n\n![Class UML diagram](../../../../public/media/classUML.webp)\n\n## Terminology\n\nUML uses the terms attributes and operations. Some object-oriented languages use different terms. Equivalent terms are:\n- attributes (UML) → fields, data members, properties, member variables\n- operations (UML) → methods (Java), procedures, messages, member functions\n\n## ENCAPSULATION\n\nEncapsulation is the primary concept of object-oriented programming. It refers to the integration of data and logic within a class' implementation that establishes the crisp interface between the implementation and any client. Encapsulation maintains high cohesion within a class and low coupling between the class' implementation and any one of its clients.\n\nA class definition declares the variables and the function prototypes. The variables store each object's data and the functions contain the logic that operates on that data. Clients access objects through calls to these functions without knowledge of the data stored within the objects or the logic that manipulates that data.\n\n![Encapsulation diagram](../../../../public/media/encapsulation.webp)\n\nA well-encapsulated class hides all implementation details within itself. The client does not see the data that the class' object stores within itself or the logic that it uses to manage its internal data. The client only sees a clean and simple interface to the object.\n\nAs long as the classes in a programming solution are well-encapsulated, any programmer can upgrade the internal structure of any object developed by another programmer without changing any client code.\n\n## INHERITANCE AND POLYMORPHISM\n\nPolymorphism relates the implementation for an object based on its type. In the figure below, the HybridCourse object involves a different mode of delivery than the Course object, but the same assessments. Both objects belong to the same hierarchy: both are Course objects.\n\nA `mode()` query on a Course type reports a different result than a `mode()` query on a Hybrid Course type. On the other hand, an `assessments()` query on a Course type reports the same result as on a HybridCourse type.\n\n![Different behavior diagram](../../../../public/media/differentBehavior.webp)\n\n![Identical behavior diagram](../../../../public/media/identicalBehavior.webp)\n\nPolymorphic programming allows us to minimize the duplication of code amongst objects that belong to the same inheritance hierarchy.\n\n**Encapsulation, inheritance, and polymorphism are the cornerstones of any object-oriented programming language.**\n\n## Summary\n\n- Objects are abstractions of the most important chunks of information from a problem domain. They distinguish the different feature sets in the problem domain.\n- A class describes the structure common to a set of similar objects. Each object in the set is a single instance of its class.\n- Encapsulation hides the implementation details within a class—the internal data and internal logic are invisible to client applications that use objects of that class.\n- We can upgrade the structure of a well-encapsulated class without altering any client code.\n- The cornerstones of object-oriented programming are encapsulation, inheritance, and polymorphism.\n\n## Course Slide\n\n- [Introduction.pdf](../../../../public/resource/Introduction.pdf)\n"
  },
  {
    "id": "IntroductionSection",
    "filename": "IntroductionSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/IntroductionSection.mdx",
    "title": "Introduction Section",
    "frontmatter": {
      "title": "Introduction Section",
      "sidebar_label": "Introduction",
      "sidebar_position": 2,
      "description": "Introduction to Object-Oriented Programming and key concepts.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Welcome to Object-Oriented\n\n[A Language for Complex Applications](#COMPLEXITY) | [Object Terminology](#ObjectTerminology)\n\n## Overview\n\nModern software applications are *intricate*, *dynamic* and *complex*. The number of lines of code can exceed the hundreds of thousands or millions. These applications evolve over time. Some take years of programming effort to mature. Creating such applications involves many developers with different levels of expertise. Their work consists of smaller stand alone and testable sub-projects; sub-projects that are transferrable, practical, upgradeable and possibly even usable within other future applications. The principles of software engineering suggest that each component should be *highly cohesive* and that the collection of components should be *loosely coupled*. Object-oriented languages provide the tools for implementing these principles.\n\n## COMPLEXITY\n\nLarge applications are complex. We address their complexity by identifying the most important features of the problem domain; that is, the area of expertise that needs to be examined to solve the problem. We express the features in terms of **data** and **activities**. We identify the data objects and the activities on those objects as complementary tasks.\n\nConsider a course enrollment system for a program in a college or university. Each participant:\n- enrolls in several face-to-face courses\n- enrolls in several hybrid courses\n- earns a grade in each course\n\nThe following structure diagram identifies the activities.\n\n![Algorithmic diagram](/media/algorithmic.webp)\n\nIf we switch our attention to the objects involved, we find a Course and a Hybrid Course. Focusing on a Course, we observe that it has a Course Code. We lookup the Code in the institution's Calendar to determine when that Course is offered.\n\nWe say that a Course has a Code and uses a Grading Scheme and that a Hybrid Course is a kind of Course. The diagram below shows these relationships between the objects in this problem domain. The connectors identify the types of relationships. The closed circle connector identifies a *has-a* relationship, the open circle connector identifies a uses-a relationship and the arrow connector identifies an *is-a-kind-of* relationship.\n\n![Class relationships diagram](/media/class_relationships.webp)\n\nIn switching our attention from the activities in the structure chart to the objects in the relationship diagram we have switched from a procedural description of the problem to an object-oriented description.\n\nThese two complementary approaches to mastering complexity date at least as far back as the ancient Greeks. Heraclitus viewed the world in **terms of process**, while Democritus viewed the world in **terms of discrete atoms**.\n\nLearning to divide a complex problem into objects and to identify the relationships amongst the objects is the subject matter of system analysis and design courses. The material covered in this course introduces some of the principal concepts of analysis and design along with the Java syntax for implementing these concepts in code.\n\n## Object Terminology\n\n#### Introduce objects and classes, Introduce encapsulation, inheritance and polymorphism\n\nObject-oriented programming reflects the way in which we manage day-to-day tasks. Professor Miller of Princeton University demonstrated that most of us can only comprehend about seven chunks of information at a time. As children, we learn to play with small sets of chunks at an early age. As we grow, we learn to break down the problems that we face into sets of manageable chunks.\n\nA chunk in object-oriented programming is called an *object*. The shared structure of a set of similar objects is called their *class*. This shared structure includes the structure of the data in the similar objects as well as the logic that works on that data.\n\nThis chapter introduces the concepts of object, class, encapsulation, inheritance and polymorphism. Subsequent chapters elaborate on each concept in detail.\n\n**ABSTRACTION**\n\nProgramming solutions to application problems consist of components. The process of designing these solutions involves abstraction. In the C programming language, we abstract common code, store it in a structure or function and refer to that structure or function from possibly multiple places in our source code, thereby avoiding code duplication.\n\nAn object-oriented programming solution to an application problem consists of components called objects. The process of designing an object-oriented solution likewise involves abstraction. We distinguish the most important features of the object, identify them publicly and hide the less important details within the object itself.\n\n![Abstraction diagram](/media/abstraction.webp)\n\nEach object has a crisp conceptual boundary and acts in ways appropriate to itself. Compare a book with a set of notes. A book has pages that are bound and can be flipped. The page order is fixed. A set of notes consists of loose pages that can be rearranged in any order. We represent the book as an object and the set of notes as another object; each object has a different structure.\n\n*Example:*\n- An ear cannot see, an eye cannot listen and a mouth cannot smell.\n- A horse cannot bark and a dog cannot croak.\n\n**CLASSES**\n\nWe describe the structure of similar objects in terms of their class. Objects of the same class have the same structure, but possibly different states. The variable types that describe their states are identical, but generally have different values. For example, all of the books in the figure above have a title and an author, but each book has a different title and a different author.\n\n![Classes diagram](/media/classes.webp)\n\nWe say that each object is an instance of its class.\n\n**UML**\n\nThe Unified Modelling Language (UML) is a general-purpose modeling language developed for describing systems of objects and relationships between their classes. This language defines standard symbols for classes and their relationships.\n\n![Class relationships diagram](/media/class_relationships.webp)\n\n**The Class Diagram**\n\nThe primary graphic in UML is the class diagram: a rectangular box with three compartments:\n1. the upper compartment identifies the class by its name\n2. the middle compartment identifies the names and types of its attributes and visibility\n3. the lower compartment identifies the names, return types and parameter types of its operations\n\nwhere visibility is one of:\n- '+': public\n- '-': private\n- '#': protected\n- ' ': default(package)\n\n![Class UML diagram](/media/classUML.webp)\n\nThe naming conventions include:\n- begin each class name with an upper case letter\n- begin each member name with a lower case letter\n- use camel case throughout all names - capitalize the first letter of every word after the first word\n\n**Terminology**\n\nUML uses the terms attributes and operations. Some object-oriented languages use different terms. Equivalent terms are:\n- attributes (UML) → fields, data members, properties, member variables\n- operations (UML) → methods (Java), procedures, messages, member functions\n\n**ENCAPSULATION**\n\nEncapsulation is the primary concept of object-oriented programming. It refers to the integration of data and logic within a class' implementation that establishes the crisp interface between the implementation and any client. Encapsulation maintains high cohesion within a class and low coupling between the class' implementation and any one of its clients.\n\nA class definition declares the variables and the function prototypes. The variables store each object's data and the functions contain the logic that operates on that data. Clients access objects through calls to these functions without knowledge of the data stored within the objects or the logic that manipulates that data.\n\n![Encapsulation diagram](/media/encapsulation.webp)\n\nA well-encapsulated class hides all implementation details within itself. The client does not see the data that the class' object stores within itself or the logic that it uses to manage its internal data. The client only sees a clean and simple interface to the object.\n\nAs long as the classes in a programming solution are well-encapsulated, any programmer can upgrade the internal structure of any object developed by another programmer without changing any client code.\n\n**INHERITANCE AND POLYMORPHISM**\n\nPolymorphism relates the implementation for an object based on its type. In the Figure below, the HybridCourse object involves a different mode of delivery than the Course object, but the same assessments. Both objects belong to the same hierarchy: both are Course objects.\n\nA mode() query on a Course type reports a different result than a mode() query on a Hybrid Course type. On the other hand, an assessments() query on a Course type reports the same result as on an HybridCourse type.\n\n![Different behavior diagram](/media/differentBehavior.webp)\n\n![Identical behavior diagram](/media/identicalBehavior.webp)\n\nPolymorphic programming allows us to minimize the duplication of code amongst objects that belong to the same inheritance hierarchy.\n\n#### Encapsulation, inheritance and polymorphism are the cornerstones of any object-oriented programming language.\n\n*[ refer to [Szalwinski, C. M.  (2011).  Introduction to C++ for C Programmers](references.html) ]*\n\n**Summary**\n\n- Objects are abstractions of the most important chunks of information from a problem domain.  They distinguish the different feature sets in the problem domain. \n- A class describes the structure common to a set of similar objects.  Each object in the set is a single instance of its class.\n- Encapsulation hides the implementation details within a class - the internal data and internal logic are invisible to client applications that use objects of that class. \n- We can upgrade the structure of a well-encapsulated class without altering any client code.\n- The cornerstones of object-oriented programming are encapsulation, inheritance and polymorphism.\n\n## Course Slide\n\n- [Introduction.pdf](/resource/Introduction.pdf)\n"
  },
  {
    "id": "PolymorphismSection",
    "filename": "PolymorphismSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/PolymorphismSection.mdx",
    "title": "Polymorphism Section",
    "frontmatter": {
      "title": "Polymorphism Section",
      "sidebar_label": "Polymorphism",
      "sidebar_position": 6,
      "description": "Polymorphism, overloading, overriding, abstract classes, and interfaces in Java.",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Polymorphism\n\n## Overloading & Overriding\n\nPolymorphism allows methods and objects to appear in many forms. This is achieved in Java through **overloading** and **overriding** methods.\n\n### Overloading\n\nOverloading allows a class to have multiple methods with the same name but different parameter types or counts.\n\n```java\npublic class Vase extends Item {\n    private int height;\n    private String material;\n\n    public Vase() {\n        super();\n        height = 0;\n        material = \"\";\n    }\n    public Vase(int height, String material) {\n        super();\n        this.height = height;\n        this.material = material;\n    }\n    public Vase(int value, String creator, int height, String material) {\n        super(value, creator);\n        this.height = height;\n        this.material = material;\n    }\n}\n```\n\nEach constructor has a unique signature. The compiler selects the correct one based on the arguments provided.\n\n```java\nVase v1 = new Vase(0, \"Dave\", 50, \"bronze\");\nVase v2 = new Vase(100, \"plaster\");\n```\n\n### Overriding\n\nOverriding allows a subclass to provide a specific implementation of a method already defined in its superclass.\n\n```java\npublic class Item {\n    protected int value;\n    protected String creator;\n    public void input() {\n        // ...\n    }\n    public void output() {\n        // ...\n    }\n}\n\npublic class Vase extends Item {\n    private int height;\n    private String material;\n    @Override\n    public void input() {\n        super.input();\n        // ...\n    }\n    @Override\n    public void output() {\n        super.output();\n        // ...\n    }\n}\n```\n\nUse the **@Override** annotation to indicate you are overriding a superclass method.\n\n## Function Bindings\n\nJava uses **static binding** (compile time) for overloaded methods and **dynamic binding** (runtime) for overridden methods.\n\n## Abstract Classes\n\nAn **abstract class** contains abstract methods (no implementation) that must be implemented by subclasses.\n\n```java\npublic abstract class Item {\n    protected int value;\n    protected String creator;\n    public abstract void displayPrice();\n}\n\npublic class Vase extends Item {\n    private int height;\n    private String material;\n    @Override\n    public void displayPrice() {\n        if (height < 100)\n            System.out.println(\"The price is 1000$\");\n        else\n            System.out.println(\"The price is 2000$\");\n    }\n}\n```\n\nSubclasses must implement all abstract methods from their superclass.\n\n## Interfaces\n\nAn **interface** defines method signatures that implementing classes must provide. Interfaces enable multiple inheritance of type.\n\n```java\npublic interface Menu {\n    void getSalad();\n    void getBeefsteak();\n}\n\npublic class Chef implements Menu {\n    public void getSalad() {\n        System.out.println(\"This is a salad\");\n    }\n    public void getBeefsteak() {\n        System.out.println(\"This is a beefsteak\");\n    }\n}\n```\n\nA class can implement multiple interfaces, providing polymorphic behavior.\n\n## Summary\n\n- Polymorphism allows objects and methods to take many forms.\n- Overloading and overriding are key techniques for polymorphism.\n- Abstract classes and interfaces enable flexible and reusable code.\n- In OOP, a parent class or interface reference can refer to a child class object.\n\n## Course Slide\n\n- [Polymorphism.pdf](/resource/Polymorphism.pdf)\n"
  },
  {
    "id": "WelcomeSection",
    "filename": "WelcomeSection.mdx",
    "relPath": "/workspaces/pro192-secrert/src/components/sections/mdx_docs/WelcomeSection.mdx",
    "title": "Welcome Section",
    "frontmatter": {
      "title": "Welcome Section",
      "sidebar_label": "Welcome",
      "sidebar_position": 1,
      "description": "Welcome and overview for Object-Oriented Programming using Java (PRO192).",
      "tags": [
        "Key Concepts"
      ]
    },
    "content": "\n# Welcome to Object-Oriented\n\n[//]: # (Navigation links)\n[A Language for Complex Applications](#COMPLEXITY) | [Object Terminology](#ObjectTerminology)\n\n## Overview\n\nModern software applications are *intricate*, *dynamic* and *complex*. The number of lines of code can exceed the hundreds of thousands or millions. These applications evolve over time. Some take years of programming effort to mature. Creating such applications involves many developers with different levels of expertise. Their work consists of smaller stand alone and testable sub-projects; sub-projects that are transferrable, practical, upgradeable and possibly even usable within other future applications. The principles of software engineering suggest that each component should be *highly cohesive* and that the collection of components should be *loosely coupled*. Object-oriented languages provide the tools for implementing these principles.\n\n## Subject title\n\nThe Object Oriented Programming using Java (PRO192)\n\n## Subject Description\n\nThis subject introduces the student to object-oriented programming. The student learns to build reusable objects, encapsulate data and logic within a class, inherit one class from another and implement polymorphism. Adhere to object-oriented programming principles including encapsulation, polymorphism and inheritance when writing program code.\n\n## Learning outcomes\n\n- Understand the concepts of object oriented (OO) programs to solve problems and fundamentals of object-oriented programming in Java\n- Practice basic Java language syntax and semantics to write Java programs and use concepts such as variables, conditional and iterative execution methods\n- Uses streams to read and write data from/to different types of sources/targets\n- Discuss the benefits and the use of JAVA's Exceptional handling mechanism\n- Identify classes, objects, members of a class and relationships among them needed for a specific problem\n- Explain the concept and demonstrates the use of Polymorphism, Encapsulation, Abstraction and Inheritance in java\n- Discuss the principles and the use of abstract classes and interfaces in java\n- Understand and implement a complete program using object array\n- Explain the principles and the use of some (java collections) abstract data types (list, set, map)\n\n## Academic policy\n\nCheating, plagiarism and breach of copyright are serious offenses under this Policy.\n\n**Cheating**  \nCheating during a test or exam is construed as talking, peeking at another student's paper or any other clandestine method of transmitting information.\n\n**Plagiarism**  \nPlagiarism is using the work of others without citing it; that is, holding the work of others out as your own work.\n\n**Breach of Copyright**  \nIf you photocopy a textbook without the copyright holder's permission, you violate copyright law.\n\n## Prerequisite(s)\n\nPRF192\n\nFor further information, see the [syllabus](/syllabus-pro192-spring2021)\n"
  }
]